/*
 * compiler/lexer.l
 * Lexer for the Q-Verifier DSL (input.qp)
 */

%{
    #include <stdio.h>
    #include <string.h>
    #include "y.tab.h" // Generated by Bison (our next step)

    // Global file pointer for the JSON token log
    FILE* token_log = NULL;
    
    // Global line number, managed by Flex
    extern int yylineno; 

    // Helper to write to the JSON log
    // We escape quotes and newlines in the value for valid JSON
    void log_token(const char* token_name, const char* value) {
        if (token_log == NULL) return;
        
        char escaped_value[2048];
        int j = 0;
        // Loop to escape special JSON characters
        for (int i = 0; value[i] != '\0' && j < 2045; i++) {
            if (value[i] == '"') {
                escaped_value[j++] = '\\';
                escaped_value[j++] = '"';
            } else if (value[i] == '\n') {
                escaped_value[j++] = '\\';
                escaped_value[j++] = 'n';
            } else if (value[i] == '\\') {
                escaped_value[j++] = '\\';
                escaped_value[j++] = '\\';
            } else {
                escaped_value[j++] = value[i];
            }
        }
        escaped_value[j] = '\0';
        
        // Note the trailing comma. We'll fix this in cleanup.
        fprintf(token_log, "  {\"token\": \"%s\", \"value\": \"%s\", \"line\": %d},\n",
                token_name, escaped_value, yylineno);
    }
%}

/* Options */
%option noyywrap
%option yylineno  /* Tell Flex to automatically track line numbers in 'yylineno' */

/* Definitions for our DSL */
/* A string is anything in double quotes */
STRING  \"[^\"]*\"

%%

    /* --- DSL Tags --- */
"["[HEADER]"]"         { log_token("T_HEADER_START", yytext); return T_HEADER_START; }
"["[/HEADER]"]"       { log_token("T_HEADER_END", yytext); return T_HEADER_END; }
"["[QUESTION_LIST]"]" { log_token("T_QUESTION_LIST_START", yytext); return T_QUESTION_LIST_START; }
"["[/QUESTION_LIST]"]" { log_token("T_QUESTION_LIST_END", yytext); return T_QUESTION_LIST_END; }
"["[QUESTION]"]"       { log_token("T_QUESTION_START", yytext); return T_QUESTION_START; }
"["[/QUESTION]"]"     { log_token("T_QUESTION_END", yytext); return T_QUESTION_END; }

    /* --- DSL Keys --- */
"SUBJECT"           { log_token("T_SUBJECT", yytext); return T_SUBJECT; }
"TOTAL_MARKS"       { log_token("T_TOTAL_MARKS", yytext); return T_TOTAL_MARKS; }
"TOTAL_TIME"        { log_token("T_TOTAL_TIME", yytext); return T_TOTAL_TIME; }
"SYLLABUS_PATH"     { log_token("T_SYLLABUS_PATH", yytext); return T_SYLLABUS_PATH; }
"Q_TEXT"            { log_token("T_Q_TEXT", yytext); return T_Q_TEXT; }
"Q_MARKS"           { log_token("T_Q_MARKS", yytext); return T_Q_MARKS; }

    /* --- DSL Values --- */
{STRING}            { 
                        /* Remove the quotes for the string value */
                        yytext[yyleng-1] = '\0'; // Remove trailing quote
                        yylval.sval = strdup(yytext + 1); // Save string (skip first quote)
                        log_token("T_STRING", yylval.sval);
                        return T_STRING; 
                    }
[0-9]+              { 
                        yylval.ival = atoi(yytext); // Save integer value
                        log_token("T_NUMBER", yytext);
                        return T_NUMBER; 
                    }

    /* --- DSL Punctuation --- */
":"                 { log_token("T_COLON", yytext); return T_COLON; }

    /* --- Whitespace & Errors --- */
[ \t\n\r]+          { /* Skip all whitespace */ }
.                   { 
                        /* Log any unknown characters as errors */
                        char error_val[2] = { yytext[0], '\0' };
                        log_token("T_ERROR_UNKNOWN", error_val);
                    }

%%

/* * These helper functions will be called by our main.c
 * This replaces the 'main' function you had.
 */

/* Opens the JSON log file for writing */
void lexer_init(const char* job_dir) {
    char log_path[1024];
    /* We get the job_dir path from main.c and write tokens.json there */
    sprintf(log_path, "%s/tokens.json", job_dir);
    
    token_log = fopen(log_path, "w");
    if (token_log == NULL) {
        perror("Failed to open tokens.json");
        return;
    }
    fprintf(token_log, "[\n"); // Start JSON array
}

/* Closes the JSON log file */
void lexer_cleanup() {
    if (token_log != NULL) {
        /* * This is a simple way to remove the last trailing comma from the JSON
         * We seek back 2 chars (to overwrite the ",\n")
         */
        fseek(token_log, -2, SEEK_CUR); 
        fprintf(token_log, "\n]\n"); // End JSON array
        fclose(token_log);
        token_log = NULL;
    }
}